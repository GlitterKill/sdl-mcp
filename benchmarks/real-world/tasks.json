{
  "version": 3,
  "defaults": {
    "baseline": {
      "maxFilesPerStep": 4,
      "maxTokensPerFile": 2200
    },
    "sdl": {
      "maxSearchTerms": 12,
      "maxSearchResultsPerTerm": 6,
      "maxEntrySymbols": 4,
      "maxCardsPerStep": 5,
      "maxCards": 14,
      "maxTokens": 3200,
      "maxSkeletonsPerStep": 1,
      "skeletonMaxLines": 120,
      "skeletonMaxTokens": 1500
    },
    "scoring": {
      "weights": {
        "tokenEfficiency": 0.45,
        "coverageQuality": 0.25,
        "efficiencyScore": 0.2,
        "precisionQuality": 0.1
      },
      "thresholds": {
        "sdlWin": 5,
        "traditionalWin": -5
      }
    }
  },
  "tasks": [
    {
      "id": "code-review-slice-pr",
      "category": "code-review",
      "title": "Review slice-expansion pull request for correctness and regressions",
      "description": "Simulates reviewing a PR that changes slice expansion and scoring behavior.",
      "contextTargets": {
        "files": [
          "src/graph/slice.ts",
          "src/graph/score.ts",
          "src/graph/minHeap.ts",
          "src/mcp/tools/slice.ts",
          "src/config/loadConfig.ts",
          "src/config/types.ts"
        ],
        "symbols": [
          "buildSlice",
          "scoreSymbol",
          "scoreSymbolWithMetrics",
          "handleSliceBuild",
          "handleSliceRefresh",
          "loadConfig",
          "SliceConfigSchema"
        ]
      },
      "workflow": [
        {
          "id": "triage-pr",
          "phase": "triage",
          "goal": "Understand what changed and what user-visible behavior could regress.",
          "prompt": "Review this PR: it adjusts slice expansion, symbol scoring, and frontier logic. Identify risky behavior changes.",
          "entrySymbolHints": [
            "buildSlice",
            "scoreSymbol",
            "handleSliceBuild"
          ],
          "artifacts": {
            "changedFiles": [
              "src/graph/slice.ts",
              "src/graph/score.ts",
              "src/graph/minHeap.ts"
            ]
          }
        },
        {
          "id": "investigate-behavior",
          "phase": "investigate",
          "goal": "Trace MCP handler flow and config impact.",
          "prompt": "Follow request flow from MCP slice handlers into graph scoring and config defaults.",
          "entrySymbolHints": [
            "handleSliceBuild",
            "handleSliceRefresh",
            "loadConfig"
          ]
        },
        {
          "id": "validate-review",
          "phase": "validate",
          "goal": "Confirm likely regressions and required tests.",
          "prompt": "Validate whether expansion/scoring changes could miss relevant symbols or inflate token usage."
        }
      ],
      "difficulty": "hard"
    },
    {
      "id": "bug-fix-policy-window-downgrade",
      "category": "bug-fix",
      "title": "Fix policy downgrade behavior for code window requests",
      "description": "Simulates debugging code window requests that should downgrade to skeleton/hotpath under policy restrictions.",
      "contextTargets": {
        "files": [
          "src/mcp/tools/code.ts",
          "src/policy/engine.ts",
          "src/code/skeleton.ts",
          "src/code/hotpath.ts",
          "src/mcp/telemetry.ts",
          "src/config/types.ts"
        ],
        "symbols": [
          "handleCodeNeedWindow",
          "PolicyEngine",
          "generateSymbolSkeleton",
          "extractHotPath"
        ]
      },
      "workflow": [
        {
          "id": "triage-error",
          "phase": "triage",
          "goal": "Reproduce and localize where downgrade fails.",
          "prompt": "Requests that should be downgraded to skeleton/hotpath are returning unexpected behavior. Find why.",
          "entrySymbolHints": [
            "handleCodeNeedWindow",
            "PolicyEngine"
          ],
          "artifacts": {
            "stackTrace": "Error: policy downgrade path not applied at handleCodeNeedWindow"
          }
        },
        {
          "id": "investigate-policy",
          "phase": "investigate",
          "goal": "Trace policy decision and fallback branches.",
          "prompt": "Track policy evaluation and fallback generation paths for skeleton and hotpath."
        },
        {
          "id": "validate-fix",
          "phase": "validate",
          "goal": "Confirm downgrade behavior across deny/allow scenarios.",
          "prompt": "Verify expected behavior for policy deny vs allow and ensure telemetry reflects decisions."
        }
      ],
      "difficulty": "medium"
    },
    {
      "id": "feature-review-mcp-tool-pattern",
      "category": "feature-review",
      "title": "Review adding a new MCP tool end-to-end",
      "description": "Simulates feature review for adding a new MCP tool handler, schema, and server registration.",
      "contextTargets": {
        "files": [
          "src/mcp/tools/index.ts",
          "src/mcp/tools/symbol.ts",
          "src/mcp/tools/repo.ts",
          "src/server.ts",
          "src/mcp/types.ts",
          "src/mcp/errors.ts"
        ],
        "symbols": [
          "registerTools",
          "handleSymbolSearch",
          "handleSymbolGetCard",
          "handleRepoStatus",
          "MCPServer"
        ]
      },
      "workflow": [
        {
          "id": "understand-pattern",
          "phase": "triage",
          "goal": "Understand current tool registration and request handling conventions.",
          "prompt": "Map the current pattern for adding a new tool, including schema, handler, and registration.",
          "entrySymbolHints": [
            "registerTools",
            "MCPServer"
          ]
        },
        {
          "id": "investigate-integration",
          "phase": "investigate",
          "goal": "Trace representative tool handlers for validation, error, and response shape.",
          "prompt": "Inspect existing handlers and identify guardrails for request parsing and typed errors.",
          "entrySymbolHints": [
            "handleSymbolSearch",
            "handleRepoStatus"
          ]
        },
        {
          "id": "validate-feature-review",
          "phase": "validate",
          "goal": "List required integration points and review risks.",
          "prompt": "Confirm what must be touched for a new tool and what can break if wiring is incomplete."
        }
      ],
      "difficulty": "medium"
    },
    {
      "id": "understanding-slice-lifecycle",
      "category": "understanding",
      "title": "Understand slice lifecycle from request to refresh",
      "description": "Simulates onboarding and understanding how slice state is built, cached, and refreshed.",
      "contextTargets": {
        "files": [
          "src/mcp/tools/slice.ts",
          "src/graph/slice.ts",
          "src/graph/cache.ts",
          "src/db/queries.ts",
          "src/mcp/types.ts"
        ],
        "symbols": [
          "handleSliceBuild",
          "handleSliceRefresh",
          "buildSlice",
          "loadSymbolCards"
        ]
      },
      "workflow": [
        {
          "id": "triage-flow",
          "phase": "triage",
          "goal": "Map top-level request flow for initial slice build.",
          "prompt": "Explain the flow from MCP slice build request into graph construction and response objects.",
          "entrySymbolHints": [
            "handleSliceBuild",
            "buildSlice"
          ]
        },
        {
          "id": "investigate-refresh",
          "phase": "investigate",
          "goal": "Understand refresh semantics and handle lifecycles.",
          "prompt": "Trace how slice refresh uses prior handles, cache, and changed symbols."
        },
        {
          "id": "validate-understanding",
          "phase": "validate",
          "goal": "Summarize critical invariants and data dependencies.",
          "prompt": "Identify invariants required to keep slice handles and card sets consistent."
        }
      ],
      "difficulty": "easy"
    },
    {
      "id": "code-change-new-slice-config",
      "category": "code-change",
      "title": "Implement a new slice configuration option safely",
      "description": "Simulates adding a new slice config option and wiring it through load, schema, and behavior layers.",
      "contextTargets": {
        "files": [
          "src/config/types.ts",
          "src/config/loadConfig.ts",
          "src/config/constants.ts",
          "src/graph/slice.ts",
          "config/sdlmcp.config.schema.json"
        ],
        "symbols": [
          "SliceConfigSchema",
          "loadConfig",
          "buildSlice"
        ]
      },
      "workflow": [
        {
          "id": "triage-config-points",
          "phase": "triage",
          "goal": "Find all source-of-truth points for config shape and defaults.",
          "prompt": "Add a new slice option and ensure schema/default/loading behavior remains aligned.",
          "entrySymbolHints": [
            "SliceConfigSchema",
            "loadConfig"
          ]
        },
        {
          "id": "investigate-runtime-use",
          "phase": "investigate",
          "goal": "Find where config is consumed in slice construction.",
          "prompt": "Trace how loaded config values influence slice build and budget behavior.",
          "entrySymbolHints": [
            "buildSlice"
          ]
        },
        {
          "id": "validate-change",
          "phase": "validate",
          "goal": "Confirm no drift between docs/schema/runtime.",
          "prompt": "Validate that config schema, parsing, and runtime defaults remain consistent."
        }
      ],
      "difficulty": "hard"
    },
    {
      "id": "performance-indexing-regression",
      "category": "performance",
      "title": "Investigate indexing performance regression",
      "description": "Simulates diagnosing a slowdown in indexing throughput across scanning, parsing, and persistence.",
      "contextTargets": {
        "files": [
          "src/indexer/indexer.ts",
          "src/indexer/fileScanner.ts",
          "src/db/queries.ts",
          "src/config/constants.ts",
          "src/cli/commands/index.ts"
        ],
        "symbols": [
          "indexRepo",
          "processFile",
          "scanRepository",
          "indexCommand"
        ]
      },
      "workflow": [
        {
          "id": "triage-regression",
          "phase": "triage",
          "goal": "Locate likely bottleneck areas quickly.",
          "prompt": "Indexing got slower. Identify likely bottlenecks from file scanning through DB writes.",
          "entrySymbolHints": [
            "indexRepo",
            "processFile"
          ]
        },
        {
          "id": "investigate-pipeline",
          "phase": "investigate",
          "goal": "Trace scanner and persistence interactions.",
          "prompt": "Follow scanner output into indexing batches and persistence operations.",
          "entrySymbolHints": [
            "scanRepository"
          ]
        },
        {
          "id": "validate-diagnosis",
          "phase": "validate",
          "goal": "Propose focused instrumentation/tests to confirm root cause.",
          "prompt": "Determine where additional timing or counters should be added to validate root cause."
        }
      ],
      "difficulty": "hard"
    },
    {
      "id": "bug-fix-call-graph-regression",
      "category": "bug-fix",
      "title": "Fix missed call edges in call graph extraction",
      "description": "Simulates debugging call-edge extraction regressions affecting downstream graph quality.",
      "contextTargets": {
        "files": [
          "src/indexer/treesitter/extractCalls.ts",
          "src/indexer/indexer.ts",
          "src/indexer/ts/tsParser.ts",
          "src/graph/slice.ts"
        ],
        "symbols": [
          "extractCalls",
          "resolveCallTarget",
          "buildSlice"
        ]
      },
      "workflow": [
        {
          "id": "triage-call-loss",
          "phase": "triage",
          "goal": "Find where call edges are dropped.",
          "prompt": "Call edge counts dropped unexpectedly. Locate likely extraction/resolution failure points.",
          "entrySymbolHints": [
            "extractCalls",
            "resolveCallTarget"
          ]
        },
        {
          "id": "investigate-resolution",
          "phase": "investigate",
          "goal": "Trace AST extraction to graph edge insertion.",
          "prompt": "Trace call expressions through extraction and resolution into the graph."
        },
        {
          "id": "validate-impact",
          "phase": "validate",
          "goal": "Check downstream impact on slice relevance.",
          "prompt": "Verify how missing call edges alter slice expansion behavior and context quality."
        }
      ],
      "difficulty": "medium"
    },
    {
      "id": "impact-analysis-delta-refactor",
      "category": "impact-analysis",
      "title": "Assess blast radius for a delta/impact refactor",
      "description": "Simulates impact analysis before and after refactoring delta-pack and blast-radius logic.",
      "contextTargets": {
        "files": [
          "src/delta/diff.ts",
          "src/delta/blastRadius.ts",
          "src/mcp/tools/delta.ts",
          "src/mcp/types.ts",
          "src/graph/slice.ts"
        ],
        "symbols": [
          "computeDelta",
          "computeBlastRadius",
          "handleDeltaGet",
          "buildSlice"
        ]
      },
      "workflow": [
        {
          "id": "triage-impact-task",
          "phase": "triage",
          "goal": "Locate primary delta and blast-radius computations.",
          "prompt": "Plan impact analysis for refactoring delta and blast-radius logic.",
          "entrySymbolHints": [
            "computeDelta",
            "computeBlastRadius",
            "handleDeltaGet"
          ]
        },
        {
          "id": "investigate-coupling",
          "phase": "investigate",
          "goal": "Trace data shape coupling with MCP response types.",
          "prompt": "Trace dependencies between delta computation, blast-radius ranking, and MCP types."
        },
        {
          "id": "validate-analysis",
          "phase": "validate",
          "goal": "Identify high-risk interfaces and regression checks.",
          "prompt": "List highest-risk interfaces and what should be covered by tests before merge."
        }
      ],
      "difficulty": "medium"
    },
    {
      "id": "test-triage-config-loading",
      "category": "test-triage",
      "title": "Triage failing config loading checks",
      "description": "Simulates handling failing tests around config loading and environment validation.",
      "contextTargets": {
        "files": [
          "src/config/loadConfig.ts",
          "src/config/types.ts",
          "src/cli/commands/doctor.ts",
          "src/cli/commands/index.ts",
          "src/config/constants.ts"
        ],
        "symbols": [
          "loadConfig",
          "SliceConfigSchema",
          "doctorCommand",
          "indexCommand"
        ]
      },
      "workflow": [
        {
          "id": "triage-test-failure",
          "phase": "triage",
          "goal": "Localize failure to config parsing or command usage.",
          "prompt": "Tests around config loading are failing. Identify whether schema, defaults, or command paths are at fault.",
          "entrySymbolHints": [
            "loadConfig",
            "doctorCommand"
          ]
        },
        {
          "id": "investigate-validation",
          "phase": "investigate",
          "goal": "Trace validation and defaulting behavior.",
          "prompt": "Follow config parsing and validation through CLI command usage paths."
        },
        {
          "id": "validate-triage",
          "phase": "validate",
          "goal": "Propose a targeted fix and verification scope.",
          "prompt": "Define a minimal fix and tests to prevent recurrence."
        }
      ],
      "difficulty": "easy"
    },
    {
      "id": "zod-schema-validation-flow",
      "repoId": "zod-oss",
      "category": "understanding",
      "difficulty": "medium",
      "title": "Understand Zod schema parse and refinement flow",
      "description": "Trace how Zod composes schema parsing, checks refinements, and surfaces typed errors.",
      "contextTargets": {
        "files": [
          "src/types.ts",
          "src/ZodError.ts",
          "src/helpers/parseUtil.ts",
          "src/helpers/errorUtil.ts"
        ],
        "symbols": [
          "ZodType",
          "ParseStatus",
          "addIssueToContext",
          "ZodError"
        ]
      },
      "workflow": [
        {
          "id": "zod-triage-parse-entry",
          "phase": "triage",
          "goal": "Locate schema parse entry points and shared parse context.",
          "prompt": "Find where parse and safeParse begin and how parse context is initialized.",
          "entrySymbolHints": [
            "ZodType",
            "ParseStatus"
          ]
        },
        {
          "id": "zod-investigate-refinements",
          "phase": "investigate",
          "goal": "Trace refinement checks and issue accumulation.",
          "prompt": "Follow refinement/check handling and determine where validation issues are appended to context."
        },
        {
          "id": "zod-validate-understanding",
          "phase": "validate",
          "goal": "Confirm how user-facing errors are materialized.",
          "prompt": "Validate how accumulated issues become ZodError instances and what information is preserved."
        }
      ]
    },
    {
      "id": "zod-bug-fix-error-path-shape",
      "repoId": "zod-oss",
      "category": "bug-fix",
      "difficulty": "hard",
      "title": "Debug incorrect nested error path formatting",
      "description": "Investigate a regression where nested object/array paths are reported incorrectly in errors.",
      "contextTargets": {
        "files": [
          "src/ZodError.ts",
          "src/helpers/errorUtil.ts",
          "src/helpers/parseUtil.ts",
          "src/types.ts"
        ],
        "symbols": [
          "ZodIssue",
          "makeIssue",
          "addIssueToContext",
          "ZodError"
        ]
      },
      "workflow": [
        {
          "id": "zod-triage-error-path",
          "phase": "triage",
          "goal": "Localize where path segments are assembled.",
          "prompt": "Nested validation errors show incorrect paths. Locate issue creation and path-merging logic.",
          "artifacts": {
            "stackTrace": "Error: expected nested path user.addresses[0].street but got user.street"
          },
          "entrySymbolHints": [
            "makeIssue",
            "addIssueToContext"
          ]
        },
        {
          "id": "zod-investigate-aggregation",
          "phase": "investigate",
          "goal": "Trace issue propagation across parse frames.",
          "prompt": "Trace how issue objects propagate through parse context for nested schemas."
        },
        {
          "id": "zod-validate-fix",
          "phase": "validate",
          "goal": "Validate expected path output for nested array/object schemas.",
          "prompt": "Confirm the fix preserves correct path shape and does not break flat-schema error reporting."
        }
      ]
    },
    {
      "id": "zod-impact-analysis-mini-refactor",
      "repoId": "zod-oss",
      "category": "impact-analysis",
      "difficulty": "medium",
      "title": "Assess blast radius of parse-context refactor",
      "description": "Estimate impact of changing shared parse context helpers used across schema types.",
      "contextTargets": {
        "files": [
          "src/helpers/parseUtil.ts",
          "src/helpers/errorUtil.ts",
          "src/types.ts"
        ],
        "symbols": [
          "ParseContext",
          "ParseStatus",
          "addIssueToContext"
        ]
      },
      "workflow": [
        {
          "id": "zod-impact-triage",
          "phase": "triage",
          "goal": "Locate central parse context helpers and call sites.",
          "prompt": "Identify shared parse context helpers and high-fanout consumers before refactor.",
          "entrySymbolHints": [
            "ParseContext",
            "ParseStatus"
          ]
        },
        {
          "id": "zod-impact-investigate",
          "phase": "investigate",
          "goal": "Trace type/shape coupling in parse and error utilities.",
          "prompt": "Trace dependencies between parse context shape and issue/error construction."
        },
        {
          "id": "zod-impact-validate",
          "phase": "validate",
          "goal": "Produce risk checklist for refactor validation.",
          "prompt": "List affected interfaces and tests needed to validate the refactor safely."
        }
      ]
    }
  ]
}
